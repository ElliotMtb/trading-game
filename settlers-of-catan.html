<html>
	<head>
		<meta charset="UTF-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<title>Settlers of Catan</title>


		<!-- ========= -->
		<!-- Libraries -->
		<!-- ========= -->

		<script src="jquery-1.10.2.min.js" type="text/javascript"></script>
		<script src="underscore-min.js" type="text/javascript"></script>
		<script src="backbone-min.js" type="text/javascript"></script>
		<script src="backbone.localStorage-min.js" type="text/javascript"></script> 
		<script src= "kinetic-v4.5.5.min.js" type="text/javascript"></script>
		<script src="pieces-builder.js" type="text/javascript"></script>
	</head>
	
	<body>
		<!-- ========= -->
		<!-- Application HTML -->
		<!-- ========= -->
		<section id="settlersapp">
			<header id="header">
				<h1>Game Setup</h1>
				<input id="new-player" placeholder="Player name" autofocus>
				<div>
					<a href="#/">Game Setup</a>
					<a href="#/playersWith2Points">Show Players with 2 Points</a>
					<a href="#/allPlayers"> Show All Players</a>
					<a href="#/begin">Start the Game</a>
				 </div>
			</header>
			<section id="main">
				<ul id="players-list"></ul>
			</section>
			<div id="gameBoardContainer" height="1200" width="1200">

			</div>	
		</section>

	<!-- Templates -->
		<script type="text/template" id="item-template">
			<div class="view">
				<input class="toggle" type="checkbox" <%= name ? 'checked' : '' %>>
				<label><%- name %></label>
				<input class="edit" value="<%- name %>">
				<button class="addPoint">add point</button>
				<button class="destroy">remove</button>
			</div>
		</script>  

	<!-- =============== -->
	<!-- Javascript code -->
	<!-- =============== -->
	<script defer="defer">
	'use strict';

	var app = {}; // create namespace for our app

	app.kineticLayer = new Kinetic.Layer();
	app.Stage = new Kinetic.Stage({
		container: 'gameBoardContainer',
		width: 900,
		height: 900
	});

	app.Intersections = new Array();

	app.IntersectionMap = new Array();

	app.IntersectionMap.push([1,2,7]);
	app.IntersectionMap.push([1,2,3]);
	app.IntersectionMap.push([1,3,4]);
	app.IntersectionMap.push([1,4,5]);
	app.IntersectionMap.push([1,5,6]);
	app.IntersectionMap.push([1,6,7]);
	app.IntersectionMap.push([2,7,19]);
	app.IntersectionMap.push([2,19,8]);
	app.IntersectionMap.push([2,8,9]);
	app.IntersectionMap.push([2,9,3]);
	app.IntersectionMap.push([3,9,10]);
	app.IntersectionMap.push([3,10,11]);
	app.IntersectionMap.push([3,11,4]);
	app.IntersectionMap.push([4,11,12]);
	app.IntersectionMap.push([4,12,13]);
	app.IntersectionMap.push([4,13,5]);
	app.IntersectionMap.push([5,13,14]);
	app.IntersectionMap.push([5,14,15]);
	app.IntersectionMap.push([5,15,6]);
	app.IntersectionMap.push([6,15,16]);
	app.IntersectionMap.push([6,16,17]);
	app.IntersectionMap.push([6,17,7]);
	app.IntersectionMap.push([7,17,18]);
	app.IntersectionMap.push([7,18,19]);
	app.IntersectionMap.push([19,8]);
	app.IntersectionMap.push([8,9]);
	app.IntersectionMap.push([9,10]);
	app.IntersectionMap.push([10,11]);
	app.IntersectionMap.push([11,12]);
	app.IntersectionMap.push([12,13]);
	app.IntersectionMap.push([13,14]);
	app.IntersectionMap.push([14,15]);
	app.IntersectionMap.push([15,16]);
	app.IntersectionMap.push([16,17]);
	app.IntersectionMap.push([17,18]);
	app.IntersectionMap.push([18,19]);

	// Hex 2 added
	// 	1{1.type, 2.type}
	//	2{1.type, 2.type}

	//Hex 3 added
	//	2{3.type}
	//	3{1.type, 3.type}
	//	10{2.type, 3.type}

	//Hex 4 added
	//  3{4.type}
	//	4{1.type, 4.type}
	//	13{3.type, 4.type}

	//Hex 5 added
	//	4{5.type}
	//	5{1.type, 5.type}
	//	16{4.type, 5.type}

	//Hex 6 added
	//	5{6.type}
	//	6{1.type, 6.type}
	//	19{5.type, 6.type}

	//Hex 7 added (last of ring 1)
	//	6{7.type}
	//	1{7.type}
	//	7{2.type, 7.type}
	//	22{6.type, 7.type}


//Complete intersection mapping

//	in-order-intersection#:{intersecting-resource-hex-by-in-order#}
	//	1:{1,2,7} 
	//	2:{1,2,3}
	//	3:{1,3,4}
	//	4:{1,4,5}
	//	5:{1,5,6}
	//	6:{1,6,7}
	//	7:{2,7,19}
	//	8:{2,19,8}
	//	9:{2,8,9}
	//	10:{2,9,3}
	//	11:{3,9,10}
	//	12:{3,10,11}
	//	13:{3,11,4}
	//	14:{4,11,12}
	//	15:{4,12,13}
	//	16:{4,13,5}
	//	17:{5,13,14}
	//	18:{5,14,15}
	//	19:{5,15,6}
	//	20:{6,15,16}
	//	21:{6,16,17}
	//	22:{6,17,7}
	//	23:{7,17,18}
	//	24:{7,18,19}
	//	25:{19,8}
	//	26:{8,9}
	//	27:{9,10}
	//	28:{10,11}
	//	29:{11,12}
	//	30:{12,13}
	//	31:{13,14}
	//	32:{14,15}
	//	33:{15,16}
	//	34:{16,17}
	//	35:{17,18}
	//	36:{18,19}




	// 0 = rock
	// 1 = brick
	// 2 = wheat
	// 3 = sheep
	// 4 = wood
	// 5 = desert

	app.rockImage = new Image();

	// once an image is loaded, refresh the draw...
	// seems that once 1 has loaded, they all have loaded
	// ...so I don't think more than 1 onload event is needed
	// right now. Although I could have a check to make sure 
	// that all images are loaded correctly...then if not, use the colors...
	app.rockImage.onload = function(){
		app.kineticLayer.draw();
	};

	app.rockImage.src = "./rock (150x134).jpg";

	app.brickImage = new Image()	
	app.brickImage.src = "./brick (150x132).jpg";

	app.wheatImage = new Image();
	app.wheatImage.src = "./wheat.jpg";

	app.sheepImage = new Image();
	app.sheepImage.src = "./sheep (150x141).jpg";

	app.woodImage = new Image();
	app.woodImage.src = "./wood.jpg";

	app.desertImage = new Image();
	app.desertImage.src = "./desert (150x139).jpg";

	app.rockPiece = function(){
		this.type = 'rock';
		this.color = 'grey';
		this.image = app.rockImage;

	};
	app.brickPiece = function(){
		this.type = 'brick';
		this.color = '#e3352b';
		this.image = app.brickImage;
	};
	app.wheatPiece = function(){
		this.type = 'wheat';
		this.color = 'yellow';
		this.image = app.wheatImage;
	};
	app.sheepPiece = function(){
		this.type = 'sheep';
		this.color = '#8EF13C';
		this.image = app.sheepImage;
	};
	app.woodPiece = function(){
		this.type = 'wood';
		this.color = 'green';
		this.image = app.woodImage;
	};
	app.desertPiece = function(){
		this.type = 'desert';
		this.color = '#f8cd8b';
		this.image = app.desertImage;
	};

	app.HexPieces = [	new app.rockPiece(),
						new app.rockPiece(),
						new app.rockPiece(),
						new app.brickPiece(),
						new app.brickPiece(),
						new app.brickPiece(),
						new app.wheatPiece(),
						new app.wheatPiece(),
						new app.wheatPiece(),
						new app.wheatPiece(),
						new app.sheepPiece(),
						new app.sheepPiece(),
						new app.sheepPiece(),
						new app.sheepPiece(),
						new app.woodPiece(),
						new app.woodPiece(),
						new app.woodPiece(),
						new app.woodPiece(),
						new app.desertPiece()];

	app.SelectHex = function(id){

		if (app.SelectedHex == id)
		{
			app.toggleSelectedHex(id);

		}
		else{
			if (app.SelectedHex != "")
			{
				app.deselectHex(app.SelectedHex);
				app.toggleSelectedHex(id);
			}
			else
			{
				app.toggleSelectedHex(id);
			}

		}

	};

	app.toggleSelectedHex = function(id){

		if(app.ring[id].getAttr('selected'))
  		{
  			app.ring[id].setStroke("black");
  			app.ring[id].setStrokeWidth("1");
  			app.ring[id].setAttr('selected', false);
  			app.SelectedHex = "";

  		}
  		else
  		{
      		app.ring[id].setStroke("blue");
      		app.ring[id].setStrokeWidth("3");
      		app.ring[id].setAttr('selected', true);

      		app.SelectedHex = id;
  		}

  		app.kineticLayer.draw();
  		app.ring[id].draw();

	};

	app.deselectHex = function(id){
		app.ring[id].setStroke("black");
  			app.ring[id].setStrokeWidth("1");
  			app.ring[id].setAttr('selected', false);
  			app.SelectedHex = "";
	};

	app.SelectedHex = "";

	app.newGuid = function(){
	    var guid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
	        var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
	         return v.toString(16);
	    });     
	    return guid;
	};

	app.piecesRemaining = 19;
	app.nextHexPiece = function(){

		var indexToTake = Math.floor((Math.random() * app.HexPieces.length));
		console.log("piecesRemaining: " + app.HexPieces.length);
		console.log("index of hex to take: " + indexToTake);
		var piece = app.HexPieces[indexToTake];

		app.HexPieces.splice(indexToTake,1);

		return piece;

	};


	app.ring = {};

	//--------------
	// Models
	/*
	app.testPolyHex = new Kinetic.RegularPolygon({
	        x: 100,
	        y: 100,
	        sides: 6,
	        radius: 25,
	        fill: 'blue',
	        stroke: 'black',
	        strokeWidth: 1
      		});

	app.kineticLayer.add(app.testPolyHex);
*/

	app.Player = Backbone.Model.extend({
		defaults: {
			name: '',
			point: 2
		},
		addPoint: function(){
			var points = this.get('point');
			console.log(this.get('name') + ' has ' + points + ' points!');

			this.save({ 'point': ++points});
		}
	});

	app.CatanHex = Backbone.Model.extend({
		defaults: {
			resourceType: 'desert',
			collectNumber: 0
		},
		hex: new Kinetic.RegularPolygon({
	        x: 150,
	        y: 150,
	        sides: 6,
	        radius: 25,
	        fill: 'yellow',
	        stroke: 'black',
	        strokeWidth: 1
      		}),
		id: app.newGuid()

	});

	app.CatanHexView = Backbone.View.extend({
		tagName: 'gameBoardContainer',
		render: function(){
			
		},
		initialize: function(){
			
			this.model.hex.on('click', this.hexClick);
		},      
		events: {
		
		},
		hexClick: function(e){

			if (this.selected == true)
			{
				this.setStroke("black");
	      		this.setStrokeWidth("1");
	      		this.draw();

	      		this.selected = false;
			}
			else{

				this.setStroke("blue");
	      		this.setStrokeWidth("3");
	      		this.draw();

	      		this.selected = true;
			}
		},
		selected: false

	});


	//--------------
	// Collections
	//--------------
	app.PlayerList = Backbone.Collection.extend({
	  model: app.Player,
      localStorage: new Store("settlers-of-catan"),
      playersWith2Points: function(){
      	return this.filter(function(player) {

      		if (player.get('point') == 2)
      		{
	      		console.log(player.get('name') + ' has EXACTLY 2 points' );
	      		console.log(player.get('name') + ' has EXACTLY 2 points' );
	      		console.log(player.get('name') + ' has EXACTLY 2 points' );
	      		console.log(player.get('name') + ' has EXACTLY 2 points' );
	      		return true;
      		}

      		console.log(player.get('name') + ' has more than 2 points' );

      		return false;
      	});
      }
	});

	// instance of the Collection
	app.playerList = new app.PlayerList();

	//--------------
	// Views
	//--------------

	// renders individual player items list (li)
	app.PlayerView = Backbone.View.extend({
	  tagName: 'li',
	  template: _.template($('#item-template').html()),
	  render: function(){
		this.$el.html(this.template(this.model.toJSON()));
		    this.input = this.$('.edit');
		    return this; // enable chained calls
	  },
	  initialize: function(){
	    this.model.on('change', this.render, this);
	  },      
	  events: {
	    'keypress .edit' : 'updateOnEnter',
        'click .destroy': 'destroy',
        'click .addPoint': 'addPoint'
	  },
	  updateOnEnter: function(e){
	    if(e.which == 13){
	      this.close();
	    }
	  },
	  destroy: function(){
        this.model.destroy();
        app.playerList.trigger('reset');
	  },
	  addPoint: function(){
	  	this.model.addPoint();
	  }
	});

	// renders the full list of todo items calling TodoView for each one.
	app.SetupView = Backbone.View.extend({
	  el: '#settlersapp',
	  initialize: function (kineticLayer, practiceHex) {
	    this.input = this.$('#new-player');
	    app.playerList.on('add', this.addAll, this);
	    app.playerList.on('reset', this.addAll, this);
	    app.playerList.fetch(); // Loads list from local storage

	    //var myHex = new app.CatanHexView({model: new app.CatanHex()});
	    //hexboard

      var hexRadius = 60;
      var radiusToFirstRing = hexRadius*Math.sqrt(3);
      var radiusToSecondRing;

      var ring1StartX = 450; //+ radiusToFirstRing;
      var ring1StartY = 450;

      var ring1EndX = ring1StartX;
      var ring1EndY = ring1StartY;

      var i;
      var hexId = 1;

      //var firstRing = new Array();

       var theCenter = app.nextHexPiece();
      //var centerGuid = app.newGuid();
      var centerGuid = 1;

      app.ring[centerGuid] = new Kinetic.RegularPolygon({
        x: ring1StartX,
        y: ring1StartY,
        sides: 6,
        radius: hexRadius,
        //fill: theCenter.color,
        fillPatternImage: theCenter.image,
	    fillPatternOffset: [-78, 70],
	    hexType: theCenter.type,
        stroke: 'black',
        strokeWidth: 1,
        id: centerGuid
      });

      var centerText = new Kinetic.Text({
        x: ring1StartX - 7,
        y: ring1StartY - 15,
        text: 1,
        fontSize: 30,
        fontFamily: 'Calibri',
        fill: 'red'
      });


      kineticLayer.add(app.ring[centerGuid]);

      kineticLayer.add(centerText);

		app.ring[centerGuid].on('click', function(e){

			app.SelectHex(this.getAttr('id'));
		});

      for(i=0; i <=5; i++)
      {

      	ring1EndX =this.getXYatArcEnd(ring1StartX, ring1StartY, radiusToFirstRing, -1*i*2*Math.PI/6)[0];
      	ring1EndY =this.getXYatArcEnd(ring1StartX, ring1StartY, radiusToFirstRing, -1*i*2*Math.PI/6)[1];

      	console.log("Ring1 Start (x,y): " + ring1StartX + "," + ring1StartY);
      	console.log("Ring1 hex " + i + " end (x,y): " + ring1EndX + "," + ring1EndY);

		//var hexGuid = app.newGuid();
		var hexGuid = i + 2;

		var hexPiece = app.nextHexPiece();

      	app.ring[hexGuid] = new Kinetic.RegularPolygon({
        x: ring1EndX,
        y: ring1EndY,
        sides: 6,
        radius: hexRadius,
        //fill: hexPiece.color,
        fillPatternImage: hexPiece.image,
        fillPatternOffset: [-78, 70],
        hexType: hexPiece.type,
        stroke: 'black',
        strokeWidth: 1,
        id : hexGuid
      	});

      	var ring1Text = new Kinetic.Text({
        x: ring1EndX - 7,
        y: ring1EndY - 15,
        text: i + 2,
        fontSize: 30,
        fontFamily: 'Calibri',
        fill: 'red'
      	});

		kineticLayer.add(app.ring[hexGuid]);

		kineticLayer.add(ring1Text);

      	app.ring[hexGuid].on('click', function(e){

      		app.SelectHex(this.getAttr('id'));
      	});

      }

      var j;

      for(j=0; j <=11; j++)
      {
      	if (j % 2 == 1){
      		radiusToSecondRing = 3 * hexRadius;
      	}
      	else
      	{
      		radiusToSecondRing = 2 * radiusToFirstRing;	
      	}
	      	ring1EndX = this.getXYatArcEnd(ring1StartX, ring1StartY, radiusToSecondRing, -1*j*2*Math.PI/12)[0];
	      	ring1EndY = this.getXYatArcEnd(ring1StartX, ring1StartY, radiusToSecondRing, -1*j*2*Math.PI/12)[1];

	      	console.log("Ring1 Start (x,y): " + ring1StartX + "," + ring1StartY);
	      	console.log("Ring1 hex " + j + " end (x,y): " + ring1EndX + "," + ring1EndY);

	      	//var hexGuid = app.newGuid();
	      	var hexGuid = j + 8;

	      	var hexPiece = app.nextHexPiece();

	      	app.ring[hexGuid] = new Kinetic.RegularPolygon({
	        x: ring1EndX,
	        y: ring1EndY,
	        sides: 6,
	        radius: hexRadius,
	        //fill: hexPiece.color,
	        fillPatternImage: hexPiece.image,
	        fillPatternOffset: [-78, 70],
	        hexType: hexPiece.type,
	        stroke: 'black',
	        strokeWidth: 1,
	        id: hexGuid
      		});

      		var ring2Text = new Kinetic.Text({
	        x: ring1EndX - 7,
	        y: ring1EndY - 15,
	        text: j + 8,
	        fontSize: 30,
	        fontFamily: 'Calibri',
	        fill: 'red'
	      	});

	      	kineticLayer.add(app.ring[hexGuid]);

	      	kineticLayer.add(ring2Text);

      		app.ring[hexGuid].on('click', function(e){

	      		app.SelectHex(this.getAttr('id'));
      		});

			
      }

		var radiusToThirdRing;
		var k;
		var angle;
		var primaryAngle = -1*2*Math.PI/6;
		var ringNumber = 3;
		var m;

		var angleList = [ringNumber];
		var radiiList = [ringNumber];

		// Draw outside "ocean" border ring
		var x;
		for(x=0; x<1; x++)
		{
			var ringN;

			for(ringN =0; ringN<ringNumber; ringN++)
			{
			var aLeg = (ringNumber-0.5*ringN)*radiusToFirstRing;
			var bLeg = (0+1.5*ringN)*hexRadius;

			angleList[ringN] = -1*Math.atan(bLeg/aLeg);
			radiiList[ringN] =  Math.sqrt(Math.pow(aLeg, 2) + Math.pow(bLeg,2));
			}

			var primaryPosition;
		  
			for(k=0; k <=(ringNumber*6)-1; k++)
			{
				primaryPosition = Math.floor(k/ringNumber)*primaryAngle;

				for(m=0; m<ringNumber; m++)
				{
					if( k % ringNumber == m)
					{
						var aLeg = (ringNumber-0.5*m)*radiusToFirstRing;
						var bLeg = (0+1.5*m)*hexRadius;
						
						//radiusToThirdRing = Math.sqrt(Math.pow(aLeg, 2) + Math.pow(bLeg,2));
						radiusToThirdRing = radiiList[m];
						//angle = -1*Math.atan(bLeg/aLeg) + primaryPosition;
						angle = angleList[m] + primaryPosition;
					}

					ring1EndX = this.getXYatArcEnd(ring1StartX, ring1StartY, radiusToThirdRing, angle)[0];
					ring1EndY = this.getXYatArcEnd(ring1StartX, ring1StartY, radiusToThirdRing, angle)[1];

					var hexGuid = k + 20;

					var hexPiece = app.nextHexPiece();

					app.ring[hexGuid] = new Kinetic.RegularPolygon({
					x: ring1EndX,
					y: ring1EndY,
					sides: 6,
					radius: hexRadius,
					fill: 'cyan',
					stroke: 'black',
					strokeWidth: 1,
					id: hexGuid
					});
					
					kineticLayer.add(app.ring[hexGuid]);
				}
			}
				  
			ringNumber++;
		}
	  
	  /*
	  //IDEA! Should develop board as a collection of hex-center points, and unique list of vertices, when building the vertices (6 around each center point), can have a unique list of vertices...only add to the unique list if not there, if vertex "collides" with existing vertex (could use a box region for collision detection) then don't add new vertex, but rather add the hex-center point as an adjacency, and add the "previous" vertex as adjacency as well (even after collision, keep sweeping around all 6 vertices of the center-point...to make sure everything gets updated if necessary). In this way, a unique list of vertices will be build along with information regarding adjacent hexes and vertices.
	  
	  //note: when "sweeping" around a center point, any newly created vertices should have "null/empty" adjacent vertices and hexes...that way, the //edges of the board will already be initialized by the time the board is built (collisions will be how the "empty/null" adjacencies become occupied).
	  
	  //Then, roads can be build to adjacenct vertices and settlements can occupy a vertex with knowledge of which 2 or 3 hexes it is adjacent to (for resource type and number
	  */
	  
	  var circlesX;
	  for( circlesX = 0; circlesX < 6; circlesX++)
	  {
		angle = -1*2*Math.PI/6 * circlesX + -1*2*Math.PI/12;
		ring1EndX = this.getXYatArcEnd(ring1StartX, ring1StartY, hexRadius, angle)[0];
	  ring1EndY = this.getXYatArcEnd(ring1StartX, ring1StartY, hexRadius, angle)[1];
	  
	  var newCircle = new Kinetic.Circle({
	        x: ring1EndX,
	        y: ring1EndY,
	        radius: 10,
	        fill: 'magenta',
	        stroke: 'black',
	        strokeWidth: 1,
      		});
			
		kineticLayer.add(newCircle);
	  }
	  for( circlesX = 0; circlesX < 6; circlesX++)
	  {
		angle = -1*2*Math.PI/6 * circlesX + -1*2*Math.PI/12;
		ring1EndX = this.getXYatArcEnd(ring1StartX, ring1StartY, hexRadius*2, angle)[0];
	  ring1EndY = this.getXYatArcEnd(ring1StartX, ring1StartY, hexRadius*2, angle)[1];
	  
	  var newCircle = new Kinetic.Circle({
	        x: ring1EndX,
	        y: ring1EndY,
	        radius: 10,
	        fill: 'magenta',
	        stroke: 'black',
	        strokeWidth: 1,
      		});
			
		kineticLayer.add(newCircle);
		
		makeCity(ring1EndX, ring1EndY, 15, 'blue', kineticLayer);
	  }
	  for( circlesX = 0; circlesX < 6; circlesX++)
	  {
		angle = -1*2*Math.PI/6 * circlesX + -1*2*Math.PI/12;
		ring1EndX = this.getXYatArcEnd(ring1StartX, ring1StartY, 4*hexRadius, angle)[0];
	  ring1EndY = this.getXYatArcEnd(ring1StartX, ring1StartY, 4*hexRadius, angle)[1];
	  
	  var newCircle = new Kinetic.Circle({
	        x: ring1EndX,
	        y: ring1EndY,
	        radius: 10,
	        fill: 'magenta',
	        stroke: 'black',
	        strokeWidth: 1,
      		});
			
		kineticLayer.add(newCircle);
		
		makeSettlement(ring1EndX, ring1EndY, 15, 'red', kineticLayer);
	  }
	  
	    ///hexboard

	    //kineticLayer.add(myHex.model.hex);

	    app.Stage.add(kineticLayer);
	    kineticLayer.draw();

	    for(var x = 1; x <= app.IntersectionMap.length; x++)
	    {
	    	console.log("Intersection " + x + ":");

		    for(var index = 0; index < app.IntersectionMap[x-1].length; index++)
		    {
		    	//alert(app.ring[index].getAttr('id'));
		    	var ringIndex = app.IntersectionMap[x-1][index];
			    //alert(app.ring[ringIndex].getAttr('id'));

			    console.log("\t" + app.ring[ringIndex].getAttr('hexType'));
		    }
		}

	  },
	  getXYatArcEnd: function(c1,c2,radius,angle){
			return [c1+Math.cos(angle)*radius,c2+Math.sin(angle)*radius];
	  },
	  events: {
	    'keypress #new-player': 'createTodoOnEnter'
	  },
	  createTodoOnEnter: function(e){
	    if ( e.which !== 13 || !this.input.val().trim() ) { // ENTER_KEY = 13
	      return;
	    }
	    app.playerList.create(this.newAttributes());
	    this.input.val(''); // clean input box
	  },
	  addOne: function(player){
	    var view = new app.PlayerView({model: player});
	    $('#players-list').append(view.render().el);
	  },
	  addAll: function(){
	    var theList = this.$('#players-list')
	    theList.html(''); // clean the todo list
	    switch(window.filter){
	
	    	case 'playersWith2Points':
		  
		    	_.each(app.playerList.playersWith2Points(), this.addOne);
		   
		    	break;
			
			case 'begin':

				break;
						    
		    default:
		 
		    	app.playerList.each(this.addOne, this);
		
		    	break;
	    }
	  },
	  newAttributes: function(){
	    return {
	      name: this.input.val().trim()
	    }
	  }
	});

	//--------------
	// Routers
	//--------------

	app.Router = Backbone.Router.extend({
	  routes: {
	    '*filter' : 'setFilter'
	  },
	  setFilter: function(params) {
	  	if (params)
	  	{ 
		    console.log('app.router.params = ' + params);
		    window.filter = params.trim();
		}
		else
		{
			window.filter = '';
		}

	    app.playerList.trigger('reset');
	  }
	});     

	//--------------
	// Initializers
	//--------------   


	
	app.playerView = new app.SetupView(app.kineticLayer, app.testPolyHex); 

	
	app.Stage.add(app.kineticLayer);
	app.kineticLayer.draw();

	app.router = new app.Router();
	Backbone.history.start();    
	

	</script>

	</body>
</html>